import * as THREE from "three";
let assets={
	"./assets/shader/frag_lights_physical_pars_fragment_Scattering.glsl": "float curve = 1.0;\r\n\r\nfloat thicknessDistortion = 0.1;\r\n//vec3 thicknessColor = vec3(0.5,0.3,0.0);\r\nfloat thicknessPower = 2.0;\r\nfloat thicknessScale = 2.0;\r\n\r\nuniform sampler2D sssLUT;//Subsurface Scattering //https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin\r\nuniform float sssIntensity;\r\nuniform float sssIntensity2;\r\nuniform float CurveFactor;\r\n\r\nvoid RE_Direct_Physical_Scattering( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n        RE_Direct_Physical( directLight, geometry, material, reflectedLight ) ;\r\n        vec3 scatteringHalf = normalize( directLight.direction + (geometry.normal * thicknessDistortion));\r\n        float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\r\n        reflectedLight.directDiffuse += scatteringDot * directLight.color * material.diffuseColor.rgb;\r\n\r\n        float wrappedDotNL = (dot(directLight.direction, geometry.normal) * 0.5 + 0.5);\r\n        vec4 scatteringColor = texture2D(sssLUT, vec2(wrappedDotNL, CurveFactor  ));\r\n        // vec4 scatteringColor = texture2D(sssLUT, vec2(wrappedDotNL, 1.0 / curve  ));//散射颜色取决于入射夹角和曲率\r\n        reflectedLight.directDiffuse += (1.0 - wrappedDotNL) * directLight.color * material.diffuseColor * scatteringColor.rgb * sssIntensity;//计算次表面散射并加入到漫反射中\r\n}\r\n#define  RE_Direct_Physical  RE_Direct_Physical_Scattering\r\n",
	"./assets/shader/frag_lights_physical_pars_fragment_Specular.glsl": "uniform float brightness_specular;\r\nfloat PHBeckmann( float NdotH , float roughness ){//余弦 , 粗糙度 //针对皮肤的高光项 //Beckmann分布函数预处理以便生成速查纹理\r\n\troughness = max(roughness,0.01);//roughness要大于0.01\r\n        float alpha = acos( NdotH );\r\n        float ta = tan(alpha);\r\n        float m = roughness * roughness ;\r\n        float val = 1.0 / ( m * pow(NdotH,4.0) ) * exp( -(ta*ta)/ m );\r\n        return val;//与roughness正相关 与alpha负相关 \r\n}\r\nfloat fresnelReflectance( vec3 H, vec3 V, float F0 )//半程方向 视线方向 常数\r\n{\r\n        float base = 1.0 - dot( V, H );  \r\n        float exponential = pow( base, 5.0 );\r\n        return exponential + F0 * ( 1.0 - exponential );//菲涅尔方程（Fresnel equations）\r\n}\r\nvoid RE_Direct_Physical_Specular( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n        RE_Direct_Physical( directLight, geometry, material, reflectedLight ) ;\r\n        float dotNL = dot( geometry.normal, directLight.direction ); //法向量与入射方向夹角的余弦值 //漫反射强度\r\n        if(dotNL > 0.0){ //如果存在漫反射\r\n            vec3 h =  directLight.direction + geometry.viewDir ; // Unnormalized half-way vector  //半程方向\r\n            vec3 H = normalize( h ); //单位化\r\n            float dotNH = dot( geometry.normal , H ); //法线与半程方向夹角的余弦 //镜面反射强度\r\n            float PH = PHBeckmann( dotNH , roughness );//针对皮肤的高光项\r\n            float F = fresnelReflectance( H,geometry.viewDir,0.028 );//针对皮肤的高光项?\r\n            float frSpec = max( PH * F / dot(h,h) , 0.0 );\r\n            reflectedLight.directSpecular +=  dotNL * brightness_specular * frSpec * directLight.color ;//添加高光\r\n        }\r\n}\r\n#define RE_Direct_Physical_Scattering RE_Direct_Physical_Specular\r\n",
	"./assets/shader/frag_MeshStandardMaterial.glsl": "#define STANDARD\r\n\r\n#ifdef PHYSICAL\r\n\t#define IOR\r\n\t#define SPECULAR\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifdef IOR\r\n\tuniform float ior;\r\n#endif\r\n\r\n#ifdef SPECULAR\r\n\tuniform float specularIntensity;\r\n\tuniform vec3 specularColor;\r\n\r\n\t#ifdef USE_SPECULARINTENSITYMAP\r\n\t\tuniform sampler2D specularIntensityMap;\r\n\t#endif\r\n\r\n\t#ifdef USE_SPECULARCOLORMAP\r\n\t\tuniform sampler2D specularColorMap;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef USE_CLEARCOAT\r\n\tuniform float clearcoat;\r\n\tuniform float clearcoatRoughness;\r\n#endif\r\n\r\n#ifdef USE_SHEEN\r\n\tuniform vec3 sheenColor;\r\n\tuniform float sheenRoughness;\r\n\r\n\t#ifdef USE_SHEENCOLORMAP\r\n\t\tuniform sampler2D sheenColorMap;\r\n\t#endif\r\n\r\n\t#ifdef USE_SHEENROUGHNESSMAP\r\n\t\tuniform sampler2D sheenRoughnessMap;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <alphatest_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_common_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <normal_pars_fragment>\r\n\r\n#include <lights_physical_pars_fragment>\r\n\r\n#include <transmission_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <clearcoat_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n//////////////////////////////////////////////////////\r\nin vec3 instanceColorOut;\r\n//////////////////////////////////////////////////////\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\t/////////////////////////////////////////////////////////////////////\r\n\tdiffuseColor.xyz +=instanceColorOut;\r\n\t/////////////////////////////////////////////////////////////////////\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <clearcoat_normal_fragment_begin>\r\n\t#include <clearcoat_normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\r\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\r\n\r\n\t#include <transmission_fragment>\r\n\r\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\r\n\r\n\t#ifdef USE_CLEARCOAT\r\n\r\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\r\n\r\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\r\n\r\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\r\n\r\n\t#endif\r\n\r\n\t#include <output_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}",
	"./assets/shader/vert_anim.glsl": "in vec3 instanceColorIn;\r\nout vec3 instanceColorOut;\r\n//////////////////////////////////////\r\nuniform sampler2D animationTexture;\r\nuniform float boneCount, animationFrameCount, animationTextureLength;\r\nuniform float time;\r\nin vec4 skinIndex, skinWeight; // 仅使用了绑定的第一个骨骼\r\nin float speed;//float speed=1.;//\r\nin float obesity;\r\nin float moveMaxLength;\r\nin float animationStartTime;\r\nin float animationIndex; // float animationIndex=0.; // 动画类型// in float animationIndex; // 动画类型//\r\nin vec4 bodyScale; // 0:身体 1:头部 2:上肢 3:下肢\r\nstruct Vertex{\r\n    vec3 position;\r\n    vec3 normal;\r\n};\r\nfloat getBoneScale(float bone) { // 身体形变\r\n    if ( bone < 3.5 || (bone > 5.5 && bone < 6.5) || (bone > 15.5 && bone < 16.5) ) // 身体\r\n        return bodyScale[0];\r\n    if ( bone > 3.5 && bone < 5.5 ) // 头部\r\n        return bodyScale[1];\r\n    if ( bone > 6.5 && bone < 15.5 || (bone > 16.5 && bone < 25.5) ) // 上肢\r\n        return bodyScale[2];\r\n    if ( bone > 25.5 ) // 下肢\r\n        return bodyScale[3];\r\n}\r\nfloat computeBodyScale() {\r\n    return (\r\n        skinWeight[0] * getBoneScale(skinIndex[0]) + \r\n        skinWeight[1] * getBoneScale(skinIndex[1]) +\r\n        skinWeight[2] * getBoneScale(skinIndex[2]) +\r\n        skinWeight[3] * getBoneScale(skinIndex[3])\r\n    );\r\n}\r\nvec4 getAnimationItem(float index) { // 从texture中提取矩阵元素\r\n    float v = floor(index / animationTextureLength);\r\n    float u = index - v * animationTextureLength;\r\n    return texture(\r\n        animationTexture, \r\n        vec2( (0.5 + u) / animationTextureLength, (0.5 + v) / animationTextureLength )\r\n    );\r\n}\r\nmat4 computeAnimationMatrix(float boneIndex, float frameIndex) { // 计算一个骨骼的变换矩阵\r\n    float startPos = //4. * boneCount +\r\n            3. * (boneCount * (animationIndex  * animationFrameCount + frameIndex) + boneIndex);\r\n    vec4 a=getAnimationItem(startPos + 0.);\r\n    vec4 b=getAnimationItem(startPos + 1.);\r\n    vec4 c=getAnimationItem(startPos + 2.);\r\n    \r\n    return mat4(\r\n        vec4(a.x,a.y,a.z, 0.),\r\n        vec4(a.a,b.x,b.y, 0.),\r\n        vec4(b.z,b.a,c.x, 0.),\r\n        vec4(c.y,c.z,c.a, 1.)\r\n    );\r\n}\r\nmat3 mat4_mat3(mat4 m){\r\n    return mat3(\r\n        m[0].xyz,\r\n        m[1].xyz,\r\n        m[2].xyz\r\n    );\r\n}\r\nVertex computeAnimationPos(float boneIndex, float frameIndex,Vertex vertex) { // 计算一个骨骼的变换矩阵\r\n    vec4 position=vec4(vertex.position, 1.);\r\n    mat4 m1=computeAnimationMatrix( boneIndex,  0.);\r\n    mat4 test=mat4(\r\n        vec4(obesity ,0.,0., 0.),\r\n        vec4(0.,1.,0., 0.),\r\n        vec4(0.,0.,obesity, 0.),\r\n        vec4(0.,0.,0., 1.)\r\n    );\r\n    mat4 m2=computeAnimationMatrix( boneIndex,  frameIndex+1.);\r\n    vertex.position=(m2*test*m1*position).xyz;\r\n\r\n    vec3 normal=vertex.normal;\r\n    mat3 m3=mat4_mat3(m1);\r\n    mat3 test2=mat4_mat3(test);\r\n    mat3 m4=mat4_mat3(m2);\r\n    vertex.normal= m4*test2*m3*normal;\r\n    return vertex;\r\n}\r\nVertex vertexBlending(Vertex vertex, float frameIndex) { // 动画形变, 计算4个骨骼的影响\r\n    if ( animationTextureLength < 0.5) return vertex; // 动画未加载\r\n    Vertex vertexResult;\r\n    vertexResult.position=vec3(0.,0.,0.);\r\n    vertexResult.normal=vec3(0.,0.,0.);\r\n    for(int i=0;i<4;i++){\r\n        Vertex v=computeAnimationPos(skinIndex[i], frameIndex,vertex) ;\r\n        vertexResult.position+=skinWeight[i] * v.position;\r\n        vertexResult.normal+=skinWeight[i] * v.normal;\r\n    }\r\n    return vertexResult;\r\n}\r\nVertex frameInterpolation(Vertex vertex) { // 点坐标插值, 考虑优化:变换矩阵插值\r\n    float m = floor((time + animationStartTime) * speed / (animationFrameCount-1.));\r\n    float temp = (time + animationStartTime) * speed - m * (animationFrameCount-1.);\r\n    float frameIndex1 = floor(temp);\r\n    float weight = temp - frameIndex1; // 插值权重\r\n    float frameIndex2 = float(int(frameIndex1 + 1.) % int(animationFrameCount));\r\n    if(frameIndex2>=animationFrameCount-1.)frameIndex2=0.;\r\n    Vertex vertex1 = vertexBlending(vertex, frameIndex1);\r\n    Vertex vertex2 = vertexBlending(vertex, frameIndex2);\r\n    vertex.position = (1. - weight) * vertex1.position + weight * vertex2.position;\r\n    vertex.normal = (1. - weight) * vertex1.normal + weight * vertex2.normal;\r\n\r\n    float max=moveMaxLength;//移动路线的长度\r\n    // float f=1.;\r\n    if(max>0.){\r\n        float direction=1.;\r\n        float x=0.25*(time + animationStartTime) * speed;\r\n\t    x=x-max*2.*floor(x/(max*2.));\r\n        if(x>max){\r\n            x=2.*max-x;\r\n            direction=-1.;\r\n        }\r\n        x-=max/2.;\r\n\t    vertex.position.x*=direction;\r\n\t    vertex.position.z*=direction;\r\n\t    vertex.position.z-=x;\r\n\r\n        vertex.normal.x*=direction;\r\n\t    vertex.normal.z*=direction;\r\n    }\r\n    return vertex;\r\n}\r\n//////////////////////////////////////",
	"./assets/shader/vert_anim_sim.glsl": "in vec3 instanceColorIn;\r\nout vec3 instanceColorOut;\r\n//////////////////////////////////////\r\nuniform sampler2D animationTexture;\r\nuniform float boneCount, animationFrameCount, animationTextureLength;\r\nuniform float time;\r\nin vec4 skinIndex, skinWeight; // 仅使用了绑定的第一个骨骼\r\nin float speed;//float speed=1.;//\r\n// in float obesity;\r\nin float moveMaxLength;\r\nin float animationStartTime;\r\nin float animationIndex; // float animationIndex=0.; // 动画类型// in float animationIndex; // 动画类型//\r\nin vec4 bodyScale; // 0:身体 1:头部 2:上肢 3:下肢\r\nstruct Vertex{\r\n    vec3 position;\r\n    vec3 normal;\r\n};\r\nfloat getBoneScale(float bone) { // 身体形变\r\n    if ( bone < 3.5 || (bone > 5.5 && bone < 6.5) || (bone > 15.5 && bone < 16.5) ) // 身体\r\n        return bodyScale[0];\r\n    if ( bone > 3.5 && bone < 5.5 ) // 头部\r\n        return bodyScale[1];\r\n    if ( bone > 6.5 && bone < 15.5 || (bone > 16.5 && bone < 25.5) ) // 上肢\r\n        return bodyScale[2];\r\n    if ( bone > 25.5 ) // 下肢\r\n        return bodyScale[3];\r\n}\r\nfloat computeBodyScale() {\r\n    return (\r\n        skinWeight[0] * getBoneScale(skinIndex[0]) + \r\n        skinWeight[1] * getBoneScale(skinIndex[1]) +\r\n        skinWeight[2] * getBoneScale(skinIndex[2]) +\r\n        skinWeight[3] * getBoneScale(skinIndex[3])\r\n    );\r\n}\r\nvec4 getAnimationItem(float index) { // 从texture中提取矩阵元素\r\n    float v = floor(index / animationTextureLength);\r\n    float u = index - v * animationTextureLength;\r\n    return texture(\r\n        animationTexture, \r\n        vec2( (0.5 + u) / animationTextureLength, (0.5 + v) / animationTextureLength )\r\n    );\r\n}\r\nmat4 computeAnimationMatrix(float boneIndex, float frameIndex) { // 计算一个骨骼的变换矩阵\r\n    float startPos = //4. * boneCount +\r\n            3. * (boneCount * (animationIndex  * (animationFrameCount-1.) + frameIndex) + boneIndex);\r\n    vec4 a=getAnimationItem(startPos + 0.);\r\n    vec4 b=getAnimationItem(startPos + 1.);\r\n    vec4 c=getAnimationItem(startPos + 2.);\r\n    \r\n    return mat4(\r\n        vec4(a.x,a.y,a.z, 0.),\r\n        vec4(a.a,b.x,b.y, 0.),\r\n        vec4(b.z,b.a,c.x, 0.),\r\n        vec4(c.y,c.z,c.a, 1.)\r\n    );\r\n}\r\nmat3 mat4_mat3(mat4 m){\r\n    return mat3(\r\n        m[0].xyz,\r\n        m[1].xyz,\r\n        m[2].xyz\r\n    );\r\n}\r\nVertex computeAnimationPos(float boneIndex, float frameIndex,Vertex vertex) { // 计算一个骨骼的变换矩阵\r\n    vec4 position=vec4(vertex.position, 1.);\r\n    // mat4 m1=computeAnimationMatrix( boneIndex,  0.);\r\n    // mat4 m2=computeAnimationMatrix( boneIndex,  frameIndex+1.);\r\n    // vertex.position=(m2*m1*position).xyz;\r\n    mat4 m=computeAnimationMatrix( boneIndex,  frameIndex);\r\n    vertex.position=(m*position).xyz;\r\n    return vertex;\r\n}\r\nVertex vertexBlending(Vertex vertex, float frameIndex) { // 动画形变, 计算4个骨骼的影响\r\n    if ( animationTextureLength < 0.5) return vertex; // 动画未加载\r\n    Vertex vertexResult;\r\n    vertexResult.position=vec3(0.,0.,0.);\r\n    // vertexResult.normal=vec3(0.,0.,0.);\r\n    for(int i=0;i<4;i++){\r\n        Vertex v=computeAnimationPos(skinIndex[i], frameIndex,vertex) ;\r\n        vertexResult.position+=skinWeight[i] * v.position;\r\n        // vertexResult.normal+=skinWeight[i] * v.normal;\r\n    }\r\n    return vertexResult;\r\n}\r\nVertex frameInterpolation(Vertex vertex) { // 点坐标插值, 考虑优化:变换矩阵插值\r\n    float m = floor((time + animationStartTime) * speed / (animationFrameCount-2.));\r\n    float temp = (time + animationStartTime) * speed - m * (animationFrameCount-2.);\r\n    float frameIndex1 = floor(temp);\r\n    float weight = temp - frameIndex1; // 插值权重\r\n    float frameIndex2 = float(int(frameIndex1 + 1.) % int(animationFrameCount-1.));\r\n    if(frameIndex2>=animationFrameCount-2.)frameIndex2=0.;\r\n    Vertex vertex1 = vertexBlending(vertex, frameIndex1);\r\n    Vertex vertex2 = vertexBlending(vertex, frameIndex2);\r\n    vertex.position = (1. - weight) * vertex1.position + weight * vertex2.position;\r\n\r\n    float max=moveMaxLength;//移动路线的长度\r\n    if(max>0.){\r\n        float direction=1.;\r\n        float x=0.25*(time + animationStartTime) * speed;\r\n\t    x=x-max*2.*floor(x/(max*2.));\r\n        if(x>max){\r\n            x=2.*max-x;\r\n            direction=-1.;\r\n        }\r\n        x-=max/2.;\r\n\t    vertex.position.x*=direction;\r\n\t    vertex.position.z*=direction;\r\n\t    vertex.position.z-=x;\r\n\r\n        vertex.normal.x*=direction;\r\n\t    vertex.normal.z*=direction;\r\n    }\r\n    return vertex;\r\n}\r\n//////////////////////////////////////",
	"./assets/shader/vert_MeshStandardMaterial.glsl": "#define STANDARD\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef USE_TRANSMISSION\r\n\r\n\tvarying vec3 vWorldPosition;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <normal_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\nvoid main() {\r\n\t// gl_Position=vec4(0.,0.,-1000.,1.);\r\n\t// return;\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\t#include <normal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t///////////////////////////////////////////\r\n\tVertex vertex;\r\n\tvertex.position=transformed;\r\n\tvertex.normal=vNormal;\r\n\t// transformed_temp=transformed;\r\n\t// vNormal_temp=vNormal;\r\n\tvertex=frameInterpolation(vertex);\r\n\t// transformed=transformed_temp;\r\n\t// vNormal=vNormal_temp;\r\n\ttransformed=vertex.position;\r\n\tvNormal=vertex.normal;\r\n\r\n    // vec4 temp=frameInterpolation(transformed);\r\n\t// transformed=temp.xyz;\r\n\t// float direction=temp.a;\r\n    instanceColorOut= instanceColorIn;//vNormal\r\n\t///////////////////////////////////////////\r\n\t#include <project_vertex>\r\n\t\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n#ifdef USE_TRANSMISSION\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n#endif\r\n}"
}
export class CrowdShader{
	constructor(opt){
		this.opt=opt
		this.path0="./assets/shader/"
	}
	async init(){
		let opt=this.opt
		var vert =await this.load("vert_MeshStandardMaterial")
		vert=this.addGlsl(vert,
			await this.load(
				opt["isSimShader"]?"vert_anim_sim":"vert_anim"
			)
		)//("vert_anim"))//
		var frag =await this.load("frag_MeshStandardMaterial")
		if(opt.scattering){
			var lights_physical_pars_fragment2=
				THREE.ShaderChunk["lights_physical_pars_fragment"]+//this.load("lights_physical_pars_fragment")+
				await this.load("frag_lights_physical_pars_fragment_Scattering")
			frag = frag.replace( '#include <lights_physical_pars_fragment>', lights_physical_pars_fragment2 )
		}
		// vert = vert.replace( '#include <project_vertex>', await this.load("vert_ProjectVertex") )
		this.fragmentShader=frag
		this.vertexShader=vert
	}
	addGlsl(origin,str0,tag){
		if(!tag)tag='#include <common>' 
		var str1='\n' + str0+ '\n' + tag + '\n' 
		return origin
				.replace( tag, str1 );
	}
	load(name) {
		let url=this.path0+name+".glsl"
		if(!assets[url]){
			console.log("加载shader",url)
			assets[url]=
				new Promise((resolve, reject) => {
            		let xhr = new XMLHttpRequest();
            		xhr.onload =  () => {
                		resolve(xhr.responseText)
            		};
            		xhr.onerror =  event => reject(event);
            		xhr.open('GET', url);
            		xhr.overrideMimeType("text/html;charset=utf-8");
            		xhr.send();
        		});
		}
        return assets[url]

    }
}